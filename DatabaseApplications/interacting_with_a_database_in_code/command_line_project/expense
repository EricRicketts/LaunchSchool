#! /usr/bin/env ruby
require 'pry-byebug'
require 'pg'

module CliConstants
  DESIRED_ORDER = %w[id created_on amount memo]
  AMOUNT = DESIRED_ORDER[2]

  RECOGNIZED_COMMANDS = %w[add clear delete list search]

  LIST_SQL = <<-SQL_LIST
  SELECT #{DESIRED_ORDER.join(', ')}
  FROM expenses;
  SQL_LIST

  HELP = <<-HELP_DOC
  An expense recording system

  Commands:

  add AMOUNT MEMO [DATE] - record a new expense
  AMOUNT - required, must be a number with at least one digit
  before the decimal and two digits after the decimal
  MEMO - required, must be in quotes if more than one word
  DATE - optional, must be in quotes and formated as
  "yyyy-mm-dd hh:mm:ss"
  You must have at least 2 arguments but no more than 3

  clear - delete all expenses

  delete NUMBER - remove expense with id NUMBER, NUMBER is required

  list - list all expenses

  search QUERY - list expenses with a matching MEMO field, QUERY
  is required and must be in quotes

  program returns an information message if input parameters
  do not match the command syntax
  HELP_DOC

  INFO_MSG = <<-INFO_MSG
  Incorrect input, consider running './expense'
  with no arguments to get a list of viable commands.
  INFO_MSG

  SQL_INSERT = <<-SQL_INSERT_TEXT
  INSERT INTO expenses (amount, memo, created_on)
  VALUES
  ($1, $2, $3);
  SQL_INSERT_TEXT

end

class TableFormat
  include CliConstants
  OFFSET = 2

  attr_accessor :fields, :values, :sum

  def initialize(result_obj, fields, values)
    @sum = result_obj.field_values(AMOUNT).sum(&:to_f)
    @fields = init_fields_hsh(fields, result_obj)
    @values = values
  end

  def print_table
    print_fields << print_values << print_total
  end

  private

  def associate_values_with_spacings
    spacings = fields.values
    values.map do |record|
      record.map.with_index do |str, idx|
        [str, spacings[idx]]
      end.to_h
    end
  end

  def format_values(values_with_spacings)
    values_with_spacings.inject([]) do |record, hsh|
      record << hsh.inject([]) do |str, (value, spacing)|
        str << value.rjust(spacing)
      end.join('|')
    end.join("\n").concat("\n")
  end

  def gen_separator
    fields.inject([]) do |str, (_, spacing)|
      str << '-' * spacing
    end.join('+').concat("\n")
  end

  def init_fields_hsh(field_names, result_obj)
    permutes = field_names.permutation(field_names.size).entries
    ordered_fields = permutes.select do |ary|
      ary == DESIRED_ORDER
    end.flatten

    ordered_fields.to_h do |name|
      [name, result_obj.field_values(name).map(&:length).max + OFFSET]
    end
  end

  def gen_field_names
    fields.inject([]) do |columns, (name, spacing)|
      columns << name.rjust(spacing)
    end.join('|').concat("\n")
  end

  def print_fields
    gen_field_names << gen_separator
  end

  def print_total
    table_header = gen_field_names
    sub_amount_value = table_header.gsub(/#{AMOUNT}/, sum.to_s.rjust(AMOUNT.length))
    cleared_string = sub_amount_value.gsub(/[[:alpha:]|_]/, "\s")
    total_line = cleared_string.gsub(/^\s{5}/, 'Total')
    gen_separator.gsub(/\+/, '-') << total_line
  end

  def print_values
    values_with_spacings = associate_values_with_spacings
    format_values(values_with_spacings)
  end

end

def add
  conn = PG::Connection.new(dbname: 'rb185')

  if ARGV.size < 3
    puts "not enough arguments"
  elsif ARGV.size > 4
    puts "too many arguments"
  else add_expense(conn, ARGV[1], ARGV[2], ARGV[3])
  end

  conn.close
end

def amount_format_correct?(amount)
  if !amount.match?(/^\d+\.\d{2}$/)
    puts "Incorrect format on AMOUNT"
    false
  else
    true
  end
end

def datetime_format_correct?(datetime)
  if !datetime.match?(/^\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}$/)
    puts "Incorrect date time format"
    false
  else
    true
  end
end

def list
  conn = PG::Connection.new(dbname: 'rb185')
  result = conn.exec(LIST_SQL)

  tf = TableFormat.new(result, result.fields, result.values)
  puts tf.print_table

  conn.close
end

def add_expense(conn, amount, memo, datetime)

  return unless amount_format_correct?(amount)

  unless datetime.nil?
    return unless datetime_format_correct?(datetime)
  end

  binding.pry
  conn.exec_params(CliConstants::SQL_INSERT, [amount, memo, date_time])
  puts "expense successfully added"
end

if ARGV.empty?
  puts CliConstants::HELP
elsif !CliConstants::RECOGNIZED_COMMANDS.include?(ARGV.first)
  puts CliConstants::INFO_MSG
else send(ARGV.first.to_sym)
end
